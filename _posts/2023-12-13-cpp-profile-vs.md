---

title: "Профилирование C++ кода в Visual Studio без инструментирования"
tagline: "Разбираемся, как решать проблемы производительности программы с помощью профилировщика Visual Studio без инструментирования"
date: 2023-12-13 14:08:43 -0000
tags:
  - performance
  - cpp
  - visual-studio
  - profiling
  - troubleshooting
header:
  overlay_image: /assets/images/cpp-profile-vs/f3873461-27d2-4e11-adf4-d439eaba8d2c.png
  overlay_filter: rgba(0, 0, 0, 0.8)

---

# Исходные данные

Рассмотрим код с проблемой производительности - он выполняется слишком долго. Проблема может показаться очевидной. Да что там показаться, так оно и есть. Но представим, что мы не знаем, где проблема.

```cpp
#include <iostream>
#include <fstream>

using namespace std;

void WriteFile1(int n)
{
  for (int i = 0; i < n; ++i)
  {
    fstream file("file.txt");
    if (file)
      file << i << " ";
  }
}

void WriteFile2(int n)
{
  for (int i = 0; i < n; ++i)
  {
    fstream file("file.txt");
    if (file)
      file << i << " ";
  }
}

int main()
{
  cout << "WriteFile small" << endl;
  WriteFile1(100000);
  cout << "WriteFile big" << endl;
  WriteFile2(1000000);
  return 0;
}
```

Можно попытаться решить задачу без специальных инструментов, измерив время выполнения участков кода "вручную". Для этого фиксируется время начала и конца выполнения участка кода и разница между ними [выводится на экран](https://pro-prof.com/forums/topic/cplusplus-time-function).

Но мы не хотим писать лишний код, поэтому используем профилировщик Visual Studio. Профилирование в Visual Studio можно выполнять с инструментированием и без. Под инструментированием подразумевается встраивание в исходный код специальных меток во время компиляции. По этим меткам профилировщик будет делать измерения. Главный недостаток здесь - нужна специальная сборка. Плюс программа становится громоздкой и немного "тормознутой".

Для профилирования без инструментирования достаточно отладочной сборки программы.Такая сборка, в общем-то, всегда под рукой и будет пошустрее инструментированной. Да, профилирование без инструментированиея выдает меньше данных и они могут быть не очень точные. Но практика показывает, что и этого часто достаточно.

# Первый запуск профилировщика

Visual Studio позволяет профилировать приложения даже если они не разрабатываются в этой среде. Пусть это будет наш случай.

Запускаем Visual Studio и пропускаем экран приветствия.

![](/assets/images/cpp-profile-vs/a5ba8807-7826-4be5-b349-da7240ca062b.png)

Переходим к запуску профилировщика производительности.

![](/assets/images/cpp-profile-vs/26271c5c-c441-4eaf-846d-4aa1e622dbcb.png)

В качестве целевого объекта выбираем "Исполняемый файл".

![](/assets/images/cpp-profile-vs/c6c87ba7-b02a-4d61-a4f3-0e2afc88e794.png)

Настраиваем параметры запуска исполняемого файла. Как минимум указываем путь к файлу. Рабочая директория пусть совпадает с директорией исполняемого файла.

![](/assets/images/cpp-profile-vs/d072aefd-0c81-4621-a4ec-8a6ffc43502e.png)

Теперь остается выбрать режим профилирования и можно запускать. "Использование ЦП" - наш случай. Профилирование без инструментирования.

![](/assets/images/cpp-profile-vs/635af341-ec66-4657-90d7-05a82e0b6900.png)

После нажатия на "Начать" будет запущена целевая программа под профилировщиком. По окончании работы программы профилировщик построит отчет.

В отчете приводится разная информация, но нам интересен критический путь. Критический путь отражает самый ресурсозатратный стек вызовов в программе. То есть в каких функциях программа проработала дольше всего. Критических путей может быть несколько. Это возможно, когда критические пути похожи по характеристикам друг с другом, либо в значительной степени выделяются на фоне остального стека.

![](/assets/images/cpp-profile-vs/fb8b7759-d0ff-4078-845c-4bb1f5cc5245.png)

Таблица критического пути содержит два параметра:

* *Общее время ЦП* - это время, затраченное функцией вместе с ее внутренними вызовами других функций. (ЦП - центральный процессор).
    
* *Собственное время ЦП* - это время, затраченное функцией, исключая ее внутренние вызовы других функций.
    

При клике на любой элемент стека критического пути открывается представление функций. Посмотрим данные по функции `WriteFile2()`.

![](/assets/images/cpp-profile-vs/1743b601-daea-4e94-bcc9-b0588fff051f.png)

На представлении функций становится понятно, что проблема производительности связана со строкой открытия файла. Она занимает 84,48% всего времени выполнения программы. Предположим, что это связано с тем, что открытие файла выполняется на каждой итерации цикла. Слишком часто...

# Второй запуск профилировщика

Попробуем вынести код открытия файла за пределы цикла и снова запустим профилирование, чтобы убедиться в правильности решения.

```cpp
#include <iostream>
#include <fstream>

using namespace std;

void WriteFile1(int n)
{
  fstream file("file.txt");
  if (file)
    for (int i = 0; i < n; ++i)
      file << i << " ";
}

void WriteFile2(int n)
{
  fstream file("file.txt");
  if (file)
    for (int i = 0; i < n; ++i)
      file << i << " ";
}

int main()
{
  cout << "WriteFile small" << endl;
  WriteFile1(100000);
  cout << "WriteFile big" << endl;
  WriteFile2(1000000);
  return 0;
}
```

Повторное профилирование показало... Ничего не показало. Программа выполнилась настолько быстро, что профилировщик не зафиксировал время выполнения вложенных функций. Общее время ЦП стало равным 3 против 6159 перед оптимизацией. Задача решена.

![](/assets/images/cpp-profile-vs/f3873461-27d2-4e11-adf4-d439eaba8d2c.png)

# Вывод

Если есть необходимость в точных измерениях времени выполнения функций, а также подсчета количества их вызовов, то без способа с инструментированием не обойтись. В остальных случаях подойдет рассмотренный метод.

---

Телеграм: [**Так себе программист**](https://t.me/mediocre_developer)